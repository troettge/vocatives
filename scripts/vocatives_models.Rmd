---
title: "Bayesian models of vocatives"
author: "Márton Sóskuthy"
date: "03/07/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Prep

Loading libraries & raw data.

```{r}
library(tidyverse)
library(ggbeeswarm)
library(brms)

v <- read_csv('../data/vocatives_processed.csv')
langs <- read_csv('../derived_data/voc_languages.csv') %>%
  filter(!(language %in% c("Korean","Alaaba")))


v <- full_join(v,langs)
v_acc_voc <- filter(v, case_broad %in% c("vocative","acc-like"))
```

## 3.1 Prosody

We have a case of quasi-complete separation, i.e. one cell of our contingency table is empty. I follow https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations and http://www.stat.columbia.edu/~gelman/research/published/priors11.pdf in using a restrictive prior to deal with the resulting run-away estimates.

```{r}
# sum-coding case_broad and scaling
v_acc_voc <- v_acc_voc %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

# raw data
v_acc_voc %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prosody_clean))

# raw data by language family
v_acc_voc %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(prosody_clean)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))
```

Some thinking is necessary for the random effect coefficients.

```{r}
v_acc_voc %>%
  group_by(family1, case_broad) %>%
  summarise(prop = mean(prosody_clean)) %>%
  ungroup()
```

Note that both intercepts and slopes will vary widely between 0% - 100% (on a probability scale): 

(1) some families have only vocatives, no accusatives, and they might all have prosodic marking (so intercept = 100%, slope not possible to estimate)
(2) some families have no prosodic marking at all in vocatives (intercept = 100%, slope = 0%)
(3) some families have prosodic marking in all vocatives, but no prosodic marking at all in accusatuves (intercept = in between, slope = 100%)

We can safely assume that much of this is due to small n's -- it's not reasonable to assume that some language families always have special prosodic marking, all that some language families always have special prosodic marking in vocatives but never in accusatives. Note that a change of 1% to 99% is roughly equivalent to a step size of 10 on the log-odds scale (0% to 100% is, of course, +Inf). It would be sensible to restrict our SD estimates so that they don't allow slopes to run away much further than this (i.e. 10). I'll use a scaled student-T distribution with df=4 (falls off slightly more gradually than in df=1 case) and scale=2 (basically rules out anything much higher than 10).

We'll also try some slightly more lenient priors (for the SDs, not the slopes/intercepts) to see the extent to which prior choice affects our models.

The scale parameter and df for the population-level slopes / intercept is based on advice from Gelman: https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations.

```{r}
priors_prosody_strict <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)
priors_prosody_lenient <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(1)", class = "cor"),
  set_prior("student_t(4,0,4)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,4)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,4)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,4)", class = "sd", coef = "case_broad_sum", group="macroarea")
)
mod_prosody_strict <- brm(prosody_clean ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_prosody_strict)
mod_prosody_lenient <- brm(prosody_clean ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_prosody_lenient)
# mod_prosody_strict <- readRDS("../models/mod_prosody_strict.rds")
# mod_prosody_lenient <- readRDS("../models/mod_prosody_lenient.rds")

summary(mod_prosody_strict)
summary(mod_prosody_lenient)
saveRDS(mod_prosody_strict, "../models/mod_prosody_strict.rds")
saveRDS(mod_prosody_lenient, "../models/mod_prosody_lenient.rds")
```

The two marginal effects plots look qualitatively very similar, with slightly wider confidence intervals around the lenient model -- unsurprising, given that this model allows random slopes to veer further away from the group trend, decreasing the amount of pooling. The pp_check's look fine for both models. I'd recommend using the strict model for the paper, as the random effects are so brittle (so we actually want more pooling!).

```{r}
marginal_effects(mod_prosody_strict, robust=T)
marginal_effects(mod_prosody_lenient, robust=T)
pp_check(mod_prosody_strict)
pp_check(mod_prosody_lenient)
```

## 3.2 Presence of consonants

No complete separation here, though it still makes sense to limit random effect variance. Still using the scaled case_broad_sum variable, so using the same prior for the population-level coefficients.


```{r}
v_acc_voc_non_zero <- filter(v_acc_voc, !is.na(form_add_all))

# raw data
v_acc_voc_non_zero %>%
  group_by(case_broad) %>%
  summarise(prop=mean(cons_pres))

# raw data by language family
v_acc_voc_non_zero %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(cons_pres)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))
```

```{r}
# rescaling case_broad
v_acc_voc_non_zero <- v_acc_voc_non_zero %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

priors_consonants <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)

mod_consonants <- brm(cons_pres ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc_non_zero, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_consonants)
# mod_consonants <- readRDS(saveRDS("../models/mod_consonants.rds")
saveRDS(mod_consonants, "../models/mod_consonants.rds")
summary(mod_consonants)
pp_check(mod_consonants)
marginal_effects(mod_consonants)
stanplot(mod_consonants, type="dens")
```

And when the data set is restricted to suffixes:

```{r}
v_acc_voc_non_zero_suff <- filter(v_acc_voc_non_zero, !is.na(form_add_suffix), morphological=="affix")

# raw data
v_acc_voc_non_zero_suff %>%
  group_by(case_broad) %>%
  summarise(prop=mean(cons_pres))

# raw data by language family
v_acc_voc_non_zero_suff %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(cons_pres)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))
```

Bayesian modelling;

```{r}
# rescaling case_broad
v_acc_voc_non_zero_suff <- v_acc_voc_non_zero_suff %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

priors_consonants <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)

mod_consonants_suff <- brm(cons_pres ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc_non_zero_suff, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_consonants)
# mod_consonants_suff <- readRDS("../models/mod_consonants_suff.rds")
saveRDS(mod_consonants_suff, "../models/mod_consonants_suff.rds")
summary(mod_consonants_suff)
pp_check(mod_consonants_suff)
marginal_effects(mod_consonants_suff)
stanplot(mod_consonants_suff, type="dens")
```

When a consonant is present, is it typically final or not?

```{r}
v_acc_voc_cons_fin <- filter(v_acc_voc_non_zero, cons_pres, !is.na(form_add_suffix))

# raw data
v_acc_voc_cons_fin %>%
  group_by(case_broad) %>%
  summarise(prop=mean(cons_end))

# raw data by language family
v_acc_voc_cons_fin %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(cons_end)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))
```

Bayesian modelling:

```{r}
v_acc_voc_cons_fin <- v_acc_voc_cons_fin %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

priors_consonants <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)

mod_c_final <- brm(cons_end ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc_cons_fin, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_consonants)
# mod_consonants_suff <- readRDS("../models/mod_c_final.rds")
saveRDS(mod_c_final, "../models/mod_c_final.rds")
summary(mod_c_final)
pp_check(mod_c_final)
marginal_effects(mod_c_final)
stanplot(mod_c_final, type="dens")
```

When a consonant is present, is it typically voiceless or voiced?

```{r}
v_acc_voc_cons <- filter(v_acc_voc_non_zero, cons_pres)

# raw data
v_acc_voc_cons %>%
  group_by(case_broad) %>%
  summarise(prop=mean(obstr_vl_pres))

# raw data by language family
v_acc_voc_cons %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(obstr_vl_pres)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))

```

Bayesian modelling:

```{r}
v_acc_voc_cons <- v_acc_voc_cons %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

priors_consonants <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)

# output of this model is very strange!
mod_vl_obstr <- brm(obstr_vl_pres ~ case_broad_sum + 
                      (1 + case_broad_sum | family1) + 
                      (1 + case_broad_sum | macroarea),
            data=v_acc_voc_cons, family="bernoulli", cores=2,
            control=list(adapt_delta=0.99),
            prior=priors_consonants)
# mod_vl_obstr <- readRDS("../models/mod_vl_obstr.rds")
saveRDS(mod_vl_obstr, "../models/mod_vl_obstr.rds")
summary(mod_vl_obstr)
pp_check(mod_vl_obstr)
marginal_effects(mod_vl_obstr)
stanplot(mod_vl_obstr, type="dens")
```

Note that the model here pretty radically overestimates the size of the effect compared to simple proportions (raw, averaged across families). As it turns out, this is due to low-n language families having a much larger number of vl obstruents in vocatives than high-n language families (where accusatives actually have a higher proportion of vl obstruents).

The summary table below shows this very clearly.

```{r}
v_acc_voc_cons %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(obstr_vl_pres),
            size=length(obstr_vl_pres)) %>%
  ungroup() %>%
  mutate(small = size <= 2) %>%
  group_by(case_broad, small) %>%
  summarise(prop=mean(prop))
```

While these low-n families have little impact on raw proportions, they have a much larger impact once the estimates for large-n families are weighted down in a mixed effects regression model.

## 3.3 Presence of vowel

Case-type has essentially zero effect on presence / absence of vowel in case marker, BUT: note that the vowel is really there most of the time.

```{r}
v_acc_voc_non_zero <- filter(v_acc_voc, !is.na(form_add_all))

# raw data
v_acc_voc_non_zero %>%
  group_by(case_broad) %>%
  summarise(prop=mean(vowel_pres))

# raw data by language family
v_acc_voc_non_zero %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(vowel_pres)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))

```

Bayesian modelling:

```{r}
# rescaling case_broad
v_acc_voc_non_zero <- v_acc_voc_non_zero %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

priors_vowel_pres <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)

mod_vowel_pres <- brm(vowel_pres ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc_non_zero, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_vowel_pres)
# mod_vowel_pres <- readRDS(saveRDS("../models/mod_vowel_pres.rds")
saveRDS(mod_vowel_pres, "../models/mod_vowel_pres.rds")
summary(mod_vowel_pres)
pp_check(mod_vowel_pres)
marginal_effects(mod_vowel_pres)
stanplot(mod_vowel_pres, type="dens")
```

## 3.4 Vowel quantity

If there's a vowel, is it long? (focus on final vowel)

```{r}
v_acc_voc_vowel <- filter(v_acc_voc, !is.na(form_add_all) & vowel_pres)

# raw data
v_acc_voc_vowel %>%
  group_by(case_broad) %>%
  summarise(prop=mean(v_long))

# raw data by language family
v_acc_voc_vowel %>%
  group_by(family1, case_broad) %>%
  summarise(prop=mean(v_long)) %>%
  ungroup() %>%
  group_by(case_broad) %>%
  summarise(prop=mean(prop))
```

Bayesian modelling:

```{r}
# rescaling case_broad
v_acc_voc_vowel <- v_acc_voc_vowel %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))

priors_v_long <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea")
)

mod_v_long <- brm(v_long ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc_vowel, family="bernoulli", cores=2, control=list(adapt_delta=0.99),
            prior=priors_v_long)
# mod_v_long <- readRDS(saveRDS("../models/mod_v_long.rds")
saveRDS(mod_v_long, "../models/mod_v_long.rds")
summary(mod_v_long)
pp_check(mod_v_long)
marginal_effects(mod_v_long)
stanplot(mod_v_long, type="dens")
```

## 3.5 Multinomial modelling of vowel quality

```{r}
v_acc_voc_v_height <- filter(v_acc_voc, !is.na(form_add_all) & vowel_pres & !is.na(v_height))

# raw data
v_acc_voc_v_height %>%
  count(case_broad, v_height) %>%
  group_by(case_broad) %>%
  mutate(prop=n/sum(n))

# raw data by language family
v_acc_voc_v_height %>%
  count(family1, case_broad, v_height) %>%
  complete(nesting(family1, case_broad), v_height, fill = list(n = 0)) %>% 
  group_by(family1, case_broad) %>%
  mutate(prop=n/sum(n)) %>%
  ungroup() %>%
  group_by(case_broad, v_height) %>%
  summarise(prop=mean(prop))
```

Bayesian modelling:

```{r}
# rescaling case_broad
v_acc_voc_v_height <- v_acc_voc_v_height %>%
  mutate(case_broad_sum=ifelse(case_broad=="vocative", 1, 0),
         case_broad_sum=case_broad_sum-mean(case_broad_sum))


priors_v_height <- c(
  set_prior("student_t(5,0,2.5)", class = "b"),
  set_prior("student_t(5,0,2.5)", class = "Intercept"),
  set_prior("lkj(2)", class = "cor"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1", dpar="mul"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="family1", dpar="mum"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1", dpar="mul"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="family1", dpar="mum"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea", dpar="mul"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "Intercept", group="macroarea", dpar="mum"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea", dpar="mul"),
  set_prior("student_t(4,0,2)", class = "sd", coef = "case_broad_sum", group="macroarea", dpar="mum")
)


mod_v_height <- brm(v_height ~ case_broad_sum + (1 + case_broad_sum | family1) + (1 + case_broad_sum | macroarea),
            data=v_acc_voc_v_height, family="categorical", cores=2, control=list(adapt_delta=0.99),
            prior=priors_v_height)

# mod_v_height <- readRDS(saveRDS("../models/mod_v_height.rds")
saveRDS(mod_v_height, "../models/mod_v_height")
summary(mod_v_height) # note that estimates here tell us about log-odds of low / mid against high response - not necessarily easily interpretable!
pp_check(mod_v_height)

marginal_effects(mod_v_height, categorical=T)

# we can do better than marginal effects!
psamp <- posterior_samples(mod_v_height)

acc_matrix <- matrix(c(1, min(v_acc_voc_v_height$case_broad_sum)))
voc_matrix <- matrix(c(1, max(v_acc_voc_v_height$case_broad_sum)))
l_over_h_samp <- as.matrix(dplyr::select(psamp, matches("b_mul")))
m_over_h_samp <- as.matrix(dplyr::select(psamp, matches("b_mum")))

# probabilities!
p_h_acc <- 1 / (1 + exp(l_over_h_samp %*% acc_matrix) + exp(m_over_h_samp %*% acc_matrix))
p_h_voc <- 1 / (1 + exp(l_over_h_samp %*% voc_matrix) + exp(m_over_h_samp %*% voc_matrix))
p_l_acc <- p_h_acc * exp(l_over_h_samp %*% acc_matrix)
p_l_voc <- p_h_voc * exp(l_over_h_samp %*% voc_matrix)
p_m_acc <- p_h_acc * exp(m_over_h_samp %*% acc_matrix)
p_m_voc <- p_h_voc * exp(m_over_h_samp %*% voc_matrix)

# estimated differences!

hist(p_h_voc - p_h_acc)
hist(p_l_voc - p_l_acc)
hist(p_m_voc - p_m_acc) # more mid vowels in vocatives - but difference is only suggestive

quantile(p_h_voc - p_h_acc, c(0.025, 0.5, 0.975))
quantile(p_l_voc - p_l_acc, c(0.025, 0.5, 0.975))
quantile(p_m_voc - p_m_acc, c(0.025, 0.5, 0.975))
ecdf(p_m_voc - p_m_acc)(0) # about 5% of the probability mass lower than 0s

stanplot(mod_v_height, type="dens")
```

